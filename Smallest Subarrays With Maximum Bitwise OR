//C++

class Solution {
public:
    vector<int> smallestSubarrays(vector<int>& nums) {
        vector<int> ans;
        int n=nums.size();
        vector<int> nextSetBitPos(32,-1);
        
        //Solve from right to left
        int maxOR=0;
        for(int i=n-1;i>=0;--i){
            maxOR|=nums[i];
            int curr=nums[i];
            int pos=0;
            while(curr){
                if(curr&1)
                    nextSetBitPos[pos]=i;
                curr/=2;
                pos++;
            }
            int max_idx=*max_element(nextSetBitPos.begin(),nextSetBitPos.end());
            if(max_idx==-1)     ans.push_back(1);//Base-case
            else                ans.push_back(max_idx-i+1);
        }
        reverse(ans.begin(),ans.end());
        return ans;
    }
};

//Java

import java.util.*;

class Solution {
    public int[] smallestSubarrays(int[] nums) {
        int n = nums.length;
        int[] ans = new int[n];

        int[] nextSetBitPos = new int[32];
        Arrays.fill(nextSetBitPos, -1);

        for (int i = n - 1; i >= 0; i--) {

            int curr = nums[i];
            int pos = 0;

            // update last seen position for each set bit
            while (curr > 0) {
                if ((curr & 1) == 1) {
                    nextSetBitPos[pos] = i;
                }
                curr >>= 1;
                pos++;
            }

            int maxIdx = -1;
            for (int x : nextSetBitPos)
                maxIdx = Math.max(maxIdx, x);

            if (maxIdx == -1)
                ans[i] = 1;
            else
                ans[i] = maxIdx - i + 1;
        }

        return ans;
    }
}


#Python

class Solution:
    def smallestSubarrays(self, nums):
        n = len(nums)
        ans = [0] * n

        nextSetBitPos = [-1] * 32

        for i in range(n - 1, -1, -1):

            curr = nums[i]
            pos = 0

            while curr > 0:
                if curr & 1:
                    nextSetBitPos[pos] = i
                curr >>= 1
                pos += 1

            max_idx = max(nextSetBitPos)

            if max_idx == -1:
                ans[i] = 1
            else:
                ans[i] = max_idx - i + 1

        return ans
