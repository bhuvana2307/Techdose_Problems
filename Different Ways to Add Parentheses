//C++

class Solution {
    vector<int> mem[20][20];
    vector<int> extract_number(string& expression,int low,int high){
        int number=0;
        while(low<=high){
            number = number*10 + expression[low]-'0';
            low++;
        }
        return {number};
    }
    vector<int> try_all_possibilities(string& expression,int low,int high){
        if(mem[low][high].size()>0)
            return mem[low][high];

        vector<int> ans;
        for(int i=low;i<=high;++i){
            if(expression[i]=='+' or expression[i]=='-' or expression[i]=='*'){
                vector<int> left = try_all_possibilities(expression,low,i-1);
                vector<int> right = try_all_possibilities(expression,i+1,high);
                for(int ele1: left){
                    for(int ele2: right){
                        if(expression[i]=='+')      ans.push_back(ele1+ele2);
                        else if(expression[i]=='-') ans.push_back(ele1-ele2);
                        else                        ans.push_back(ele1*ele2);
                    }
                }
            }
        }
        if(ans.size()==0)
            return mem[low][high] = extract_number(expression,low,high);
        return mem[low][high] = ans;
    }
public:
    vector<int> diffWaysToCompute(string expression) {
        return try_all_possibilities(expression,0,expression.size()-1);
    }
};

//Java

import java.util.*;

class Solution {

    List<Integer>[][] mem = new ArrayList[20][20];

    private List<Integer> extractNumber(String expr, int low, int high) {
        int number = 0;
        for (int i = low; i <= high; i++) {
            number = number * 10 + (expr.charAt(i) - '0');
        }
        return Arrays.asList(number);
    }

    private List<Integer> compute(String expr, int low, int high) {
        if (mem[low][high] != null)
            return mem[low][high];

        List<Integer> ans = new ArrayList<>();

        for (int i = low; i <= high; i++) {
            char c = expr.charAt(i);
            if (c == '+' || c == '-' || c == '*') {

                List<Integer> left = compute(expr, low, i - 1);
                List<Integer> right = compute(expr, i + 1, high);

                for (int a : left) {
                    for (int b : right) {
                        if (c == '+') ans.add(a + b);
                        else if (c == '-') ans.add(a - b);
                        else ans.add(a * b);
                    }
                }
            }
        }

        // If no operator found → it's a number
        if (ans.isEmpty()) {
            mem[low][high] = extractNumber(expr, low, high);
            return mem[low][high];
        }

        mem[low][high] = ans;
        return ans;
    }

    public List<Integer> diffWaysToCompute(String expression) {
        return compute(expression, 0, expression.length() - 1);
    }
}


#Python

class Solution:
    def diffWaysToCompute(self, expression: str):
        mem = {}

        def extract_number(low, high):
            number = 0
            for i in range(low, high + 1):
                number = number * 10 + (ord(expression[i]) - ord('0'))
            return [number]

        def compute(low, high):
            if (low, high) in mem:
                return mem[(low, high)]

            ans = []

            for i in range(low, high):
                if expression[i] in "+-*":
                    left = compute(low, i - 1)
                    right = compute(i + 1, high)

                    for a in left:
                        for b in right:
                            if expression[i] == '+':
                                ans.append(a + b)
                            elif expression[i] == '-':
                                ans.append(a - b)
                            else:
                                ans.append(a * b)

            # If no operator → it's just a number
            if not ans:
                mem[(low, high)] = extract_number(low, high)
                return mem[(low, high)]

            mem[(low, high)] = ans
            return ans

        return compute(0, len(expression) - 1)
