//C++

class MyCalendarTwo {
    map<int,int> stops;
public:
    MyCalendarTwo() {
    }
    
    bool book(int start, int end) {
        //Include the interval by default
        stops[start]++;
        stops[end]--;

        int booked = 0; //Count of number of overlaps
        for(auto& stop: stops){ //Check with all bookings already done
            booked += stop.second;
            if(booked>2){       //No available seat
                stops[start]--;
                stops[end]++;

                //Remove unnecessary entries
                if(stops[start]==0)
                    stops.erase(start);
                if(stops[end]==0)
                    stops.erase(end);
                
                return false;
            }
        }
        return true;
    }
};

//Java

import java.util.*;

class MyCalendarTwo {

    private TreeMap<Integer, Integer> stops;

    public MyCalendarTwo() {
        stops = new TreeMap<>();
    }

    public boolean book(int start, int end) {
        // Add the interval first
        stops.put(start, stops.getOrDefault(start, 0) + 1);
        stops.put(end, stops.getOrDefault(end, 0) - 1);

        int booked = 0;

        // Sweep over all timeline points
        for (int val : stops.values()) {
            booked += val;
            if (booked > 2) {
                // rollback the change
                stops.put(start, stops.get(start) - 1);
                if (stops.get(start) == 0)
                    stops.remove(start);

                stops.put(end, stops.get(end) + 1);
                if (stops.get(end) == 0)
                    stops.remove(end);

                return false;
            }
        }
        return true;
    }
}


#Python

class MyCalendarTwo:

    def __init__(self):
        self.stops = {}  # maps time -> +1 / -1

    def book(self, start: int, end: int) -> bool:
        # add the interval
        self.stops[start] = self.stops.get(start, 0) + 1
        self.stops[end] = self.stops.get(end, 0) - 1

        booked = 0

        # sweep in sorted order
        for time in sorted(self.stops.keys()):
            booked += self.stops[time]
            if booked > 2:
                # rollback
                self.stops[start] -= 1
                if self.stops[start] == 0:
                    del self.stops[start]

                self.stops[end] += 1
                if self.stops[end] == 0:
                    del self.stops[end]

                return False

        return True
